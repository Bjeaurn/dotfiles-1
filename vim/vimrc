" ***************************************
" ***  Define plugins
" ***************************************

call plug#begin('~/.vim/plugged')

Plug 'derekwyatt/vim-scala'
Plug 'fcpg/vim-fahrenheit'
Plug 'janko-m/vim-test'
Plug 'junegunn/fzf.vim' | Plug '/usr/local/opt/fzf'
Plug 'lifepillar/vim-mucomplete'
Plug 'ludovicchabant/vim-gutentags'
Plug 'mhinz/vim-grepper'
Plug 'sheerun/vim-polyglot'
Plug 'SirVer/ultisnips'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-dispatch'
Plug 'tpope/vim-sensible'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-vinegar'
Plug 'vimwiki/vimwiki'
Plug 'wincent/terminus'
Plug 'w0rp/ale'

call plug#end()



" ***************************************
" ***  Behavior
" ***************************************

" Put swap files and backups in . only as a last resort
set directory-=.
set directory+=.
set backupdir-=.
set backupdir+=.
" Leaders
let g:mapleader="\<space>"
let g:maplocalleader=','
" Search more easily
set ignorecase smartcase

augroup vimStartup
    autocmd!

    " When editing a file, always jump to the last known cursor position.
    " Don't do it when the position is invalid, when inside an event handler
    " (happens when dropping a file on gvim) and for a commit message (it's
    " likely a different one than last time).
    autocmd BufReadPost *
      \ if line("'\"") >= 1 && line("'\"") <= line("$") && &ft !~# 'commit'
      \ |   exe "normal! g`\""
      \ | endif
augroup END



" ***************************************
" ***  Appearance
" ***************************************

" Make it look purty (but suppress the error if the colorscheme doesn't exist)
silent! colorscheme fahrenheit
set background=dark
" Use a nice font with ligatures
if has('gui_running')
    set guifont=Fira\ Code\ Retina:h13
    if has('gui_macvim')
        set macligatures
    endif
endif
" Show line-numbers
set number
" Don't wrap lines in the middle of a word. That's not cool.
set linebreak



" ***************************************
" ***  Silly shift-pressing mistakes
" ***************************************

if has('user_commands')
    command! -bang -nargs=* -complete=file E e<bang> <args>
    command! -bang -nargs=* -complete=file W w<bang> <args>
    command! -bang -nargs=* -complete=file Wq wq<bang> <args>
    command! -bang -nargs=* -complete=file WQ wq<bang> <args>
    command! -bang Wa wa<bang>
    command! -bang WA wa<bang>
    command! -bang Q q<bang>
    command! -bang QA qa<bang>
    command! -bang Qa qa<bang>
endif



" ***************************************
" ***  Plugin configurations
" ***************************************

" *** ALE
" Run linting on save only
let g:ale_lint_on_text_changed = 'never'
" Put the results in the quickfix list instead of the location list
let g:ale_set_loclist = 0
let g:ale_set_quickfix = 1

" *** FZF
let g:fzf_command_prefix = 'Fzf'
" Key mappings within FZF to define how to open a file
let g:fzf_action = {
    \ 'enter': 'e',
    \ 'space': 'split'
    \ }

" *** MUcomplete
set completeopt+=menuone,noinsert
let g:mucomplete#chains = {}
let g:mucomplete#chains.default  = ['ulti', 'omni', 'path', 'keyn', 'dict', 'uspl']

" *** netrw
let g:netrw_liststyle = 3

" *** Ultisnips
" Override key bindings not avoid conflict with MUcomplete
let g:UltiSnipsExpandTrigger = '<F20>'         " Do not use <tab>
let g:UltiSnipsJumpForwardTrigger = '<S-Tab>'  " Do not use <c-j>

" *** Vim-Test
let test#strategy = 'dispatch'

" *** VimWiki
let g:vimwiki_list = [{'path': '~/Dropbox/vimwiki', 'syntax': 'markdown', 'ext': '.md'}]
let g:vimwiki_global_ext = 0
let g:vimwiki_folding = 'expr'



" ***************************************
" ***  VIM itself!
" ***************************************

" Open vimrc
:command! EditVimrc e ~/.vim/vimrc
" Reload vimrc
:command! ReloadVimrc source ~/.vim/vimrc
" Reload vimrc whenever it's written
augroup AutoSourceVimrc
    autocmd!
    autocmd BufWritePost vimrc ReloadVimrc
augroup END



" ***************************************
" ***  File types
" ***************************************

augroup VimWiki
    autocmd!
    autocmd FileType vimwiki setlocal foldexpr=StackedMarkdownFolds()
    autocmd FileType vimwiki :call SetTabstop(2)
augroup END
augroup Java
    autocmd!
    autocmd BufRead pom.xml compiler maven
    autocmd FileType java compiler maven
    autocmd FileType java :call SetTabstop(4)
augroup END
augroup Scala
    autocmd FileType scala compiler maven
augroup END
augroup SQL
    autocmd!
    autocmd FileType sql setlocal commentstring=--\ %s
augroup END
augroup Vim
    autocmd FileType vim :call SetTabstop(4)
augroup END
augroup XML
    autocmd FileType xml :call SetTabstop(4)
augroup END



" ***************************************
" ***  Toggles
" ***************************************

" Define a set of tabstop settings and raise a flag if we have done so in this buffer
function! SetTabstop(stop)
    exec 'setlocal expandtab smarttab tabstop=' . a:stop . ' shiftwidth=' . a:stop . ' softtabstop=' . a:stop
    let b:TabstopDefined = '¯\_(ツ)_/¯'
endfunction
" Set a nice default tab stop level if it wasn't already set by an autocmd
if !exists('b:TabstopDefined')
    call SetTabstop(2)
endif

" Wrapping
function! ToggleWrap()
    if &wrap
        set nowrap
    else
        set wrap
    endif
endfunction
set nowrap



" ***************************************
" ***  Mappings
" ***************************************

" *** No prefix: general mappings

" Pressing up in a long line gets you to the above line 'in the screen',
" but if you precede it with a count, you get the old behavior
" and if the count > 5, we'll also add it to the jump list so we can do C-O and C-I
nnoremap <expr> j v:count ? (v:count > 5 ? "m'" . v:count : '') . 'j' : 'gj'
nnoremap <expr> k v:count ? (v:count > 5 ? "m'" . v:count : '') . 'k' : 'gk'

" Allow for easy window switching.
nnoremap <C-H> <C-W>h
nnoremap <C-J> <C-W>j
nnoremap <C-K> <C-W>k
nnoremap <C-L> <C-W>l
nnoremap _ <C-W>_
nnoremap - <C-W>-
nnoremap + <C-W>+
nnoremap = <C-W>=
nmap <leader>] :sp<CR>:exec("tag " . expand("<cword>"))<CR>
" Mappings for vim-commentary
xmap \ <Plug>Commentary
nmap \ <Plug>Commentary
omap \ <Plug>Commentary
nmap \\ <Plug>CommentaryLine
nmap <leader>\ <Plug>Commentary<Plug>Commentary

nnoremap <F12> :VimwikiIndex<CR>

" *** Prefix <leader><leader>: change settings
nnoremap <silent> <leader><leader>2 :call SetTabstop(2)<CR>:echo "Indentation level: 2"<CR>
nnoremap <silent> <leader><leader>4 :call SetTabstop(4)<CR>:echo "Indentation level: 4"<CR>
nnoremap <silent> <leader><leader>8 :call SetTabstop(8)<CR>:echo "Indentation level: 8"<CR>
nnoremap <silent> <leader><leader>0 :set noexpandtab nosmarttab tabstop=4 shiftwidth=4 softtabstop=4<CR>:echo "Indentation level: tab"<CR>
nnoremap <silent> <leader><leader>w :call ToggleWrap()<CR>

" *** Prefix <leader>f: finding things
nnoremap <leader>fB :b#<CR>
nnoremap <leader>fb :FzfBuffers<CR>
nnoremap <leader>ff :FzfFiles<CR>
nnoremap <leader>ft :FzfTags<CR>
nnoremap <leader>fg :Grepper -tool ag -grepprg ag --vimgrep "$*"<CR>
nnoremap <leader>f* :Grepper -open -switch -cword -noprompt<CR>
" Open netrw
nmap <leader>fn <Plug>VinegarVerticalSplitUp

" *** Prefix <leader>b: running builds
nnoremap <leader>bb :Make<CR>

" *** Prefix <leader>t: running tests
nnoremap <leader>ta :TestSuite<CR>
nnoremap <leader>tf :TestFile<CR>
nnoremap <leader>tt :TestNearest<CR>

" *** Insert mode paren, quote and <CR> expansion
inoremap <expr> ( <SID>ExpandParenFully() ? "()\<Left>" : "("
inoremap <expr> ) <SID>NextChar() == ")" ? "\<Right>" : ")"

inoremap <expr> [ <SID>ExpandParenFully() ? "[]\<Left>" : "["
inoremap <expr> ] <SID>NextChar() == "]" ? "\<Right>" : "]"

inoremap <expr> { <SID>ExpandParenFully() ? "{}\<Left>" : "{"
inoremap <expr> } <SID>NextChar() == "}" ? "\<Right>" : "}"

inoremap <expr> " <SID>NextChar() == '"' ? "\<Right>" : <SID>ExpandParenFully() ? '""<left>' : '"'
inoremap <expr> ' <SID>NextChar() == "'" ? "\<Right>" : <SID>ExpandParenFully() ? "''<left>" : "'"
inoremap <expr> ` <SID>NextChar() == "`" ? "\<Right>" : <SID>ExpandParenFully() ? "``<left>" : "`"

inoremap <expr> <CR> mucomplete#ultisnips#expand_snippet(<SID>SmartReturn())
inoremap <expr> <BS> <SID>SmartBackspace()

function! s:ExpandParenFully()
    let l:char = <SID>NextChar()
    return l:char ==? '' || index([' ', ')', ']', '}', '"', '''', '`'], l:char) >= 0
endfunction

function! s:SmartReturn()
    let l:prev = <SID>PrevChar()
    if l:prev !=? '' && index(['(', '[', '{'], l:prev) >= 0
        return "\<CR>\<Esc>O"
    else
        return "\<CR>"
    endif
endfunction

function! s:SmartBackspace()
    let l:prev = <SID>PrevChar()
    let l:next = <SID>NextChar()
    let l:doIt = (l:prev ==? '(' && l:next ==? ')') || (l:prev ==? '[' && l:next ==? ']') || (l:prev ==? '{' && l:next ==? '}') ||
               \ (l:prev ==? '''' && l:next ==? '''') || (l:prev ==? '"' && l:next ==? '"') || (l:prev ==? '`' && l:next ==? '`')
    if l:doIt
        return "\<BS>\<Del>"
    else
        return "\<BS>"
    endif
endfunction

function! s:NextChar()
    return strpart(getline('.'), col('.')-1, 1)
endfunction

function! s:PrevChar()
    return strpart(getline('.'), col('.')-2, 1)
endfunction

" *** Command-line mode
" Expand %% to the directory of the currently open file, in Command-Line mode.
" # is the 'other' file, because % would be the Command-Line window itself.
cnoremap %% <C-R>=expand('#:h').'/'<CR>

